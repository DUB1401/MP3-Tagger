# Разработка парсера
Разработка парсерного модуля для Melon максимально упрощена и унифицирована. Пройдите этот путь поэтапно вместе с этой инструкцией.

## Инструкция

### 0. Определения

Для лучшего понимания терминологии Melon рекомендуется ознакомиться с основными определениями, введёнными в процессе разработки.

| **Термин**                 | **Определение**                                                                                                                    |
|----------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| Домашний каталог парсера   | Директория с относительным путём `/Parsers/[PARSER_NAME]`. Также под этим может пониматься корень подмодуля Git.                     |
| Дополнение контента        | Процесс получения и записи в структуры описания глав контента (слайдов или абзацев).                                               |
| Формат описательного файла | Набор правил о заполняемых ключах и типах их значений в описательном файле. Подробнее [здесь](/Docs/Examples).                          |
| Коллекция                  | Текстовый файл _Collection.txt_ в домашнем каталоге парсера, содержащий список алиасов тайтлов, разделённых символом новой строки. |
| Описательный файл          | Файл с расширением JSON, содержащий в себе все данные о конкретном тайтле в соответствии с одним из поддерживаемых форматов.       |

### 1. Выбор типа парсера

Melon поддерживает два типа контента: манга и ранобэ. Шаблоны обоих типов располагаются в директории [Templates](/Docs/Templates). Вам необходимо выбрать требуемый шаблон и скопировать его в каталог [Parsers](/Parsers), назвав доменным именем ресурса (разрешены только символы латинского алфавита).

В файл _requirements.txt_ заносятся зависимости вашего будущего парсера. Будьте внимательны! Все парсеры работают в одном вирутальном окружении, потому переопределение зависимостей из главного [файла](/requirements.txt) может привести к ошибкам совместимости.

Ваши зависимости можно включить в главный файл, добавив в него строчку с подставленным именем модуля:
```
-r /Parsers/[PARSER_NAME]/requirements.txt
```

В файле _settings.json_ определяются настройки парсера. Все опции из шаблона обязательно должны быть указаны в нём, а для каких-либо дополнительных параметров используется раздел `custom`.

### 2. Внедрение базового функционала

Чтобы упростить задачу, инициализация менеджера запросов и подсчёт глав без данных о содержимом уже реализованы в приватных методах. В качестве примера эталонной реализации можно использовать парсеры, поставляющиеся вместе с Melon.

Ваша задача заключается в том, чтобы все свойства класса возвращали описываемые ими значения, а также вы должны предоставить рабочие методы `amend` и `parse` и, опционально, такие методы, как `collect`, `get_updates` и `repair`.

Хранение данных внутри парсера происходит при помощи формата описания JSON под названием _melon-manga_, параметры которого можно найти [здесь](/Docs/Examples/melon-manga.md).

#### amend
```Python
def amend(self, content: dict | None = None, message: str = "") -> dict:
		"""
		Дополняет каждую главу в кажой ветви информацией о содержимом.
			content – контент тайтла;
			message – сообщение для портов CLI.
		"""
```

#### get_updates
```Python
def get_updates(self, hours: int) -> list[str]:
		"""
		Возвращает список алиасов тайтлов, обновлённых на сервере за указанный период времени.
			hours – количество часов, составляющих период для получения обновлений.
		"""
```

#### parse
```Python
def parse(self, slug: str, message: str = ""):
		"""
		Получает основные данные тайтла.
			slug – алиас тайтла, использующийся для идентификации оного в адресе;
			message – сообщение для портов CLI.
		"""
```

#### repair
```Python
def repair(self, content: dict, chapter_id: int) -> dict:
		"""
		Получает данные о содержимом конкретной главы.
			content – контент тайтла;
			chapter_id – целочисленный идентификатор главы.
		"""
```

Для выполнения запросов рекомендуется использовать библиотеку [dublib](https://github.com/DUB1401/dublib) и её модуль `WebRequestor`, но подойти могут и любые другие библиотеки, структура ответа которых мимикрирует под `requests.Response` (содержит _status_code_).

### 3. Поддержка портов

Для работы с CLI, логами и временными файлами предоставляются так называемые порты, позволяющие выводить данные в унифицированном формате. Каждый парсер на разных этапах своей работы может использовать следующие порты:

**Порты CLI**

Доступ к портам CLI осуществляется посредством обычного импорта из [Templates](/Source/CLI/Templates.py).


* PrintAmendingProgress
* PrintStatus

**Порты логов**

Доступ к портам логов осуществляется из коллекции системных объектов `self.__SystemObjects.logger`.

* amending_end
* chapter_amended
* chapter_repaired
* chapter_skipped
* covers_unstubbed
* parsing_start
* request_error
* updates_collected

Кроме того, доступ к логам можно осуществлять через имплементацию Melon, что позволяет последнему обрабатывать их при помощи файлов конфигурации (см. [Настройка логов](/Docs/LOGGER.md)).

```Python
self.__SystemObjects.logger.info("Info")
self.__SystemObjects.logger.warning("Warning")
self.__SystemObjects.logger.error("Error")
self.__SystemObjects.logger.critical("Critical")
```

**Порты временных файлов**

Парсеру может понадобиться хранить какие-либо сторонние файлы, тебующиеся обработчику контента, и, чтобы не засорять директории Melon, в последнем доступен порт для лёгкого получения доступа к каталогу _Temp_. Для каждого парсера внутри данной директории создаётся свой подраздел.

```Python
# Получение пути к каталогу временных файлов парсера.
Path = self.__SystemObjects.temper.get_parser_temp(NAME)
# Очистка каталога временных файлов парсера.
self.__SystemObjects.temper.clear_parser_temp(NAME)
```

Очистка выделенной директории парсера производится автоматически при каждом запуске оного.

### 4. Рекомендации

Как и любой хороший Open Source проект, Melon имеет ряд рекомендаций по чистоте кода парсеров, а также взаимодействию модулей и их структуре. Следуя им, вы однозначно повысите качество интеграции своего парсера с системой.

| **Номер** | **Описание**                                                                                                                                     |
|-----------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| 1         | Парсер должен выполнять все файловые операции внутри своей директории, исключая доступ к каталогам хранения данных и временных файлов.           |
| 2         | Все сетевые запросы парсера должны поддерживать проброс через прокси-сервер.                                                                     |
| 3         | Следует использовать только порты CLI/логов для общения с пользователем.                                                                         |
| 4         | Ограничивайте частоту запросов к серверу: это позволяет не только избежать блокировок, но и не создаёт избыточную нагрузку на источник контента. |
| 5         | Всегда указывайте в описательных файлах авторов и переводчиков. Уважайте чужой труд.                                                             |

### 5. Работа с парсером

Такие вещи, как CLI, логи, обработка команд, а также работа с описательными данными ложатся на плечи Melon. Предоставив парсер и правильно его настроив, вы можете использовать его так же непринуждённо, как и встроенные модули. Описание доступных методов находится в [корне репозитория](/README.md).

В случае возникновения вопросов свяжитесь с разработчиком: [@DUB1401](https://github.com/DUB1401).
