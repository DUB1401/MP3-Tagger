# Разработка парсера
Разработку парсерного модуля для Melon максимально упрощена и унифицирована. Пройдите этот путь поэтапно вместе с этой инструкцией.

## Инструкция

1. **Выбор типа парсера**

Melon поддерживает два типа контента: манга и ранобэ. Шаблоны обоих типов располагаются в директории [Templates](/Docs/Templates). Вам необходимо выбрать требуемый шаблон и скопировать его в каталог [Parsers](/Parsers), назвав доменным именем ресурса (разрешены только символы латинского алфавита).

В файл _requirements.txt_ заносятся зависимости вашего будущего парсера. Будьте внимательны! Все парсеры работают в одном вирутальном окружении, потому переопределение зависимостей из главного [файла](/requirements.txt) может привести к ошибкам совместимости.

Ваши зависимости можно включить в главный файл, добавив в него строчку с подставленным именем модуля:
```
-r Parsers/module_name/requirements.txt
```

В файле _settings.json_ определяются настройки парсера. Все настройки из шаблона обязательно должны быть указаны в нём, а для каких-либо дополнительных параметров создан ключ `custom`. Стоит отметить, что использование базовых настроек самим парсером не является обязательным.

2. **Внедрение базового функционала**

Чтобы упростить задачу, инициализация менеджера запросов и подсчёт глав без данных о содержимом уже реализованы в приватных методах. В качестве примера эталонной реализации можно использовать парсеры, поставляющиеся вместе с Melon.

Ваша задача заключается в том, чтобы все свойства класса возвращали описываемые ими значения, а также вы должны предоставить рабочие методы `amend` и `parse` и, опционально, такие методы, как `build`, `collect` и `repair`.

Хранение данных внутри парсера происходит при помощи формата описания JSON под названием _melon-manga_, параметры которого можно найти [здесь](/Docs/Examples/melon-manga.md)

### parse
```Python
def parse(self, slug: str):
		"""
		Получает основные данные тайтла.
			slug – алиас тайтла, использующийся для идентификации оного в адресе.
		"""
```
### amend
```Python
def amend(self, content: dict | None = None, message: str = "") -> dict:
		"""
		Дополняет каждую главу в кажой ветви информацией о содержимом.
			content – контент тайтла;
			message – сообщение для портов CLI.
		"""
```

### repair
```Python
def repair(self, content: dict, chapter_id: int) -> dict:
		"""
		Получает данные о содержимом конкретной главы.
			content – контент тайтла;
			chapter_id – целочисленный идентификатор главы.
		"""
```

Для выполнения запросов рекомендуется использовать библиотеку [dublib](https://github.com/DUB1401/dublib) и её модуль `WebRequestor`, но подойти могут и любые другие библиотеки, структура ответа которых мимикрирует под `requests.Response` (содержит _status_code_).

3. **Поддержка портов**

Для работы с CLI и логами предоставляются так называемые порты, позволяющие выводить данные в унифицированном формате. Каждый парсер на разных этапах своей работы может использовать следующие порты:

**Порты CLI**

Доступ к портам CLI осуществляется посредством обычного импорта из [Templates](/Source/CLI/Templates.py).

```Python
def PrintAmendingProgress(message: str, current_state: int, max_state: int):
	"""
	Выводит в консоль прогресс дополнение глав информацией о содержимом.
		message – сообщение из внешнего обработчика;
		current_state – индекс текущей дополняемой главы;
		max_state – количество глав, которые необходимо дополнить.
	"""
```

**Порты логов**

Доступ к портам логов осуществляется из коллекции системных объектов `self.__SystemObjects.logger`.

```Python
def amending_end(self, slug: str, chapters_cont: int):
		"""
		Записывает в лог информацию о количестве дополненных глав.
			slug – алиас;
			chapters_cont – количество дополненных глав.
		"""
```

```Python
def chapter_amended(self, slug: str, chapter_id: int, is_paid: bool):
		"""
		Записывает в лог данные дополненной главы.
			slug – алиас;
			chapter_id – идентификатор главы;
			is_paid – является ли глава платной.
		"""
```

```Python
def chapter_repaired(self, slug: str, chapter_id: int, is_paid: bool):
		"""
		Записывает в лог данные дополненной главы.
			slug – алиас;
			chapter_id – идентификатор главы;
			is_paid – является ли глава платной.
		"""
```

```Python
def covers_unstubbed(self, slug: str):
		"""
		Записывает в лог информацию об удалении обложек по причине того, что те являются заглушками.
			slug – алиас.
		"""
```

```Python
def parsing_start(self, slug: str):
		"""
		Записывает в лог сообщение об успешном парсинге данных тайтла.
			slug – алиас.
		"""
```

```Python
def request_error(self, response: WebResponse, text: str | None = None):
		"""
		Обрабатывает ошибку сети.
			response – объект WEB-ответа;
			text – описание ошибки.
		"""
```

Кроме того, доступ к логам можно осуществлять через имплементацию Melon, что позволяет последнему обрабатывать их при помощи файлов конфигурации (см. [Настройка логов](/Docs/LOGGER.md)).

```Python
self.__SystemObjects.logger.info("Info")
self.__SystemObjects.logger.warning("Warning")
self.__SystemObjects.logger.error("Error")
self.__SystemObjects.logger.critical("Critical")	
```

4. **Работа с парсером**

Такие вещи, как CLI, логи, обработка команд, а также работа с описательными данными ложатся на плечи Melon. Предоставив парсер и правильно его настроив, вы можете использовать его так же непринуждённо, как и встроенные модули.
